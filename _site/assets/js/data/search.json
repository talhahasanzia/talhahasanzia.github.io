[ { "title": "Business Rule Engines 101 - What, How, When Where?", "url": "/posts/BUSINESS-RULE-ENIGNES/", "categories": "Backend, Business_Rules_Engine", "tags": "data, java, businessrules, bre", "date": "2025-01-24 05:00:00 +0500", "snippet": "Business Rule EngineA Business Rule Engine (BRE) is a software tool or system that helps you define, manage, and execute business rules separately from your main application logic.What Are Business...", "content": "Business Rule EngineA Business Rule Engine (BRE) is a software tool or system that helps you define, manage, and execute business rules separately from your main application logic.What Are Business Rules? Business rules are simple “if-then” statements or logic that govern how a system behaves. Example: “If a customer’s purchase total is over $100, apply a 10% discount.” “If the user is under 18, do not allow registration.” Why Use a Business Rule Engine?In traditional programming, business logic is often “hard-coded” into the application (e.g., inside if-else statements). While this works, it becomes harder to maintain as rules grow or change. A BRE solves this problem by: Decoupling rules from code: Business rules are stored separately and managed independently of the core application. Simplifying maintenance: You can change rules without modifying the app’s source code. Empowering non-programmers: Some BREs have a user-friendly interface so non-developers (like business analysts) can define or update rules themselves.How Does a BRE Work? Rule Definition: You define rules in a specific format (e.g., JSON, XML, or a domain-specific language). Some BREs offer a visual editor. Rule Evaluation: When the system runs, the BRE evaluates the rules based on the input data and triggers actions accordingly. Output: The BRE decides what actions to take, such as calculating discounts, approving loans, or sending notifications.Example for BeginnersLet’s say you’re building a shopping app. Without a BRE, you might write this logic in your app:fun applyDiscount(purchaseAmount: Double): Double { return if (purchaseAmount &gt; 100) { purchaseAmount * 0.9 // Apply 10% discount } else { purchaseAmount }}With a BRE, you’d move this rule to a rule engine (like Drools or Easy Rules) and write something like this in a rule file:rules: - name: DiscountRule condition: \"purchaseAmount &gt; 100\" action: \"applyDiscount(10)\" # 10% discountYour app just sends the purchase amount to the rule engine, which evaluates the rules and applies the discount if necessary. The advantage? When you want to change the discount, you update the rule file, not the app’s code.Why Should You Care About BREs? Scalability: As your project grows, managing rules in code becomes messy. BREs make scaling easier. Flexibility: Rules can be added or updated dynamically without redeploying your app. Clarity: BREs make it clear which rules are in place and how they’re applied, helping you avoid bugs. Collaboration: Business teams can contribute directly to the rules without involving developers.Advantages of Using a Business Rule EngineUsing a business rule engine (BRE) instead of directly writing business logic in code offers significant advantages in certain scenarios. Here’s why you might choose a BRE and some examples to illustrate its value:1. Separation of Logic from Code Why: Keeps business logic independent of the core application code, making it easier for non-technical users (e.g., business analysts) to modify rules without involving developers. Example: In an insurance application, the rules for calculating premiums can be frequently updated based on market conditions. A BRE allows analysts to update these rules without modifying and redeploying the main application.2. Flexibility and Agility Why: Business rules often change frequently due to evolving policies, regulations, or strategies. A BRE enables easy updates without redeploying the entire application. Example: A retail application uses a BRE to define discount policies. When a new promotional campaign starts, marketing teams can add or update discount rules directly in the BRE.3. Consistency and Reusability Why: Centralizing rules in a BRE ensures consistent behavior across the application, avoiding duplication and potential errors. Example: In a loan processing system, eligibility criteria (e.g., minimum credit score, income requirements) are reused across multiple modules like application evaluation, reporting, and compliance.4. Rule Prioritization and Chaining Why: BREs support advanced rule execution techniques like prioritization, chaining, and conflict resolution, which are hard to implement in custom code. Example: In a fraud detection system, rules can be chained (e.g., checking transaction amount, location, and customer history) to trigger actions like flagging suspicious activities.5. Transparency and Auditability Why: BREs provide clear and structured rule definitions (e.g., in DRL, DMN, or spreadsheets) that are easier to review, understand, and audit. Example: In a healthcare system, treatment eligibility rules must be auditable to comply with regulatory requirements. BREs provide traceable decision logs for each rule applied.6. Reduced Development Effort Why: Non-developers can write, test, and manage rules without involving the software development team. Example: A subscription service allows product managers to configure pricing tiers and promotions through a BRE without waiting for engineering changes.7. Support for Complex Scenarios Why: BREs can handle complex decision-making scenarios like forward and backward chaining, or rules that depend on dynamic data. Example: In supply chain management, rules to optimize inventory levels based on demand forecasts and supplier lead times can be dynamically adjusted in a BRE.Real-World Examples Banking and Finance Loan approvals, fraud detection, credit risk assessment, and interest rate calculations. Example: A bank uses a BRE to define loan eligibility rules, like minimum credit scores and income thresholds. As regulations change, rules can be updated easily without redeploying the app. Healthcare Patient eligibility for treatments, insurance claims processing, and compliance with healthcare regulations. Example: A hospital uses a BRE to check if a patient qualifies for a particular insurance-covered procedure. E-commerce Dynamic pricing, discounts, and personalized recommendations. Example: During Black Friday, a BRE is used to implement rules like “10% off for purchases above $100” or “Free shipping for members.” Telecommunications Plans, pricing, promotions, and service eligibility. Example: A telecom operator uses a BRE to manage roaming charges and apply region-specific discounts. Manufacturing and Supply Chain Inventory management, supplier selection, and production planning. Example: A factory uses a BRE to adjust production schedules based on real-time stock levels and demand forecasts. Government and Public Services Tax calculations, benefits eligibility, and compliance with regulations. Example: A government tax portal uses a BRE to calculate tax liabilities based on complex rules that vary by income level, deductions, and exemptions. When to Use a BRE Over Custom CodeYou should consider a BRE if: Rules change frequently and need rapid updates. Non-technical users need control over rules. Complex decision-making or dynamic behavior is required. Auditability and transparency are critical. You aim for scalability and consistency in rule management.If your rules are static, straightforward, and unlikely to change often, custom code may be more appropriate. However, for dynamic, business-critical applications, a BRE provides significant long-term benefits.Comparison Rule Engine Backend/Frontend Languages Supported Persistence Handling UI Salient Features Free/Paid Drools Backend Java, Kotlin Manual (XML, DRL, DB) Yes (Drools Workbench) Enterprise-grade, support for complex rule chaining, decision tables, and flows. Free &amp; Open-Source Easy Rules Backend Java, Kotlin Manual (JSON, YAML, or custom) No Lightweight, simple API for defining rules, prioritization, and chaining support. Free &amp; Open-Source OpenRules Backend Java, Excel, Google Sheets Manual (Excel, DB) Yes (Excel/Google Sheets) Spreadsheet-based rule definitions, ideal for non-technical users, Excel support. Free &amp; Paid (Dual) RuleBook Backend Java, Kotlin Manual (Java code) No Functional programming style, rule chaining, and prioritization via lambdas. Free &amp; Open-Source Camunda Backend Java Manual (DB, XML) Yes (DMN Editor) Decision model and notation (DMN), drag-and-drop UI for workflows and decisions. Free &amp; Paid (Dual) JRuleEngine Backend Java Manual (Custom XML/DB) No Lightweight, custom XML-based rule definitions, simple API for integration. Free &amp; Open-Source nRules Backend C# (Xamarin for mobile) Manual (DB or JSON) No LINQ-based rules, highly customizable, strong .NET ecosystem support. Free &amp; Open-Source Decision.js Frontend/Backend JavaScript Manual (JSON, DB) No JSON-based rule definitions, designed for JavaScript environments, WebView usable. Free &amp; Open-Source Apache Jexl Backend Java, Kotlin Manual (Custom) No Lightweight expression-based evaluation, ideal for dynamic logic in apps. Free &amp; Open-Source FICO Blaze Advisor Backend Java, C# Auto (Database integration) Yes Cloud-native with enterprise-grade UI, advanced decision management capabilities. Paid IBM ODM Backend Java Auto (Database integration) Yes Scalable enterprise-grade BRE with built-in rule editing and decision automation. Paid Kogito Backend Java, Kotlin, Quarkus Manual (DRL, DB, JSON) No Cloud-native, event-driven, tightly integrated with Drools and BPMN. Free &amp; Open-Source PowerRules Frontend/Backend JavaScript, TypeScript Manual (JSON, DB) Yes (Optional Web UI) JSON-driven rule engine for frontend or server-side logic with optional UI tools. Free &amp; Open-Source Contents gathered from ChatGPT." }, { "title": "Data Bites 101 - The teams that never fell below top 10 FIFA rankings", "url": "/posts/DATA-BITES-101/", "categories": "Data, Visualization", "tags": "data, python, datavisualization, mathplotlib", "date": "2024-04-10 00:00:00 +0500", "snippet": "Data Bites 01: The teams that never fell below top 10 FIFA rankingsThe primary question we wanted to explore was simple: is there any team that has consistently remained in the top 10 of the FIFA r...", "content": "Data Bites 01: The teams that never fell below top 10 FIFA rankingsThe primary question we wanted to explore was simple: is there any team that has consistently remained in the top 10 of the FIFA rankings since they started? We were curious if any team maintained such consistent performance, and this could be easily answered with a data visualization experiment.The Dataset: FIFA Team Rankings from KaggleWe found a free dataset on Kaggle that contained FIFA team rankings from 1993 to 2018. This dataset provided all the information We needed to answer the question. It was structured with dates and ranks for every team, making it easy to filter and visualize the data.Data Structure: Rankings of All Teams from 1993 to 2018The dataset contained rankings for every team between 1993 and 2018. Each entry had a date, team name, and their ranking for that period. With this structure, we could easily track teams’ ranks over time and create a visual representation to analyze which teams performed the best.Code:Prerequisites: Python, mathplotlib, seabornimport pandas as pdimport seaborn as snsimport matplotlib.pyplot as pltfrom matplotlib.animation import FuncAnimation# Load the dataset from a CSV filedf = pd.read_csv('rankings.csv')# Convert the rank_date column to datetime formatdf['rank_date'] = pd.to_datetime(df['rank_date'])# Group by country and filter out those who were ever ranked greater than 10countries_never_below_10 = df.groupby('country_full').filter(lambda x: x['rank'].max() &lt;= 10)['country_full'].unique()# Filter the dataset to only include these countriesfiltered_df = df[df['country_full'].isin(countries_never_below_10)]# Sort by rank_datefiltered_df = filtered_df.sort_values(by='rank_date')# Initialize the plotfig, ax = plt.subplots(figsize=(16, 8))# Set up the basic plot elementsax.set_title('Animated Rank Trend of Countries Never Below Rank 10', fontsize=16)ax.set_xlabel('Year', fontsize=14)ax.set_ylabel('Rank', fontsize=14)# Customize the y-axismax_rank = 10 # Maximum rank value you want to displayax.set_ylim(max_rank, 0) # Flip the y-axis with 0 on top and max rank at the bottomax.set_yticks(range(0, max_rank + 1)) # Show ranks from 1 to max_rank# Create a color palette for the countriespalette = sns.color_palette(\"hsv\", len(countries_never_below_10))# Define a dictionary to store the line objects for each countrylines = {country: ax.plot([], [], label=country, color=palette[i])[0] for i, country in enumerate(countries_never_below_10)}# Set up legendax.legend()# Update function for animationdef update(frame): current_date = filtered_df['rank_date'].unique()[frame] data_until_now = filtered_df[filtered_df['rank_date'] &lt;= current_date] for country, line in lines.items(): country_data = data_until_now[data_until_now['country_full'] == country] line.set_data(country_data['rank_date'], country_data['rank']) ax.set_xlim(filtered_df['rank_date'].min(), filtered_df['rank_date'].max()) return lines.values()# Number of frames in the animation corresponds to the number of unique rank_date valuesnum_frames = len(filtered_df['rank_date'].unique())# Create the animation and make it smoother by increasing frames and reducing intervalani = FuncAnimation(fig, update, frames=num_frames, repeat=False, interval=16) # Set interval to 100ms for smoother animation# Display the animationplt.show()Interestingly, we couldnt find much. That brings us to a question, is there really any team that stayed in top 10 since rankings?The answer is No.Lets broader the scale to 25 teams, and see if there are teams that never ranked below 25 since it seem hard to find team that have retained above 10 ranks.Change the following piece of code in previous code sample:countries_never_below_10 = df.groupby('country_full').filter(lambda x: x['rank'].max() &lt;= 10)['country_full'].unique()Visualizing and Analyzing the Data: Key InsightsSo we found only 5 teams that have been able to retain top 25 rankings, Brazil came close to retaining top 10 but fell below around 2012-2014 period. Germany Italy Brazil Argentina Spain Italy has never been below 21. Top rankings are dominated by European countries Brazil and Argentina were only teams outside Europe that never fell below rank 25. Brazil stayed longest in top 10 rankings from 1992 to July 2012.ConclusionIn just a few minutes, we was able to use free tools, data, and a bit of coding help to answer an interesting question about FIFA team rankings. This is just one example of how anyone can perform a quick and fun data experiment with minimal effort.Stay tuned for more Data Bites!" }, { "title": "Android - Understanding Ordered Broadcasts", "url": "/posts/ordered-broadcast/", "categories": "Android, APIs", "tags": "android, broadcasts, orderedbroadcast, receivers", "date": "2024-03-22 00:00:00 +0500", "snippet": "Understanding Ordered BroadcastsBroadcasts in Android are powerful tools for inter-component communication, allowing different parts of an application or even different applications to send and rec...", "content": "Understanding Ordered BroadcastsBroadcasts in Android are powerful tools for inter-component communication, allowing different parts of an application or even different applications to send and receive messages. Among the types of broadcasts, ordered broadcasts stand out as a mechanism for ensuring a specific order of receiver execution and enabling receivers to manipulate the propagation of the broadcast. In this article, we’ll delve into the concept of ordered broadcasts, provide examples, and compare them with normal broadcasts.Ordered Broadcasts: What Are They?Ordered broadcasts are a type of broadcast in Android where the order of receiver execution is maintained. When an ordered broadcast is sent, receivers are invoked one at a time based on their priority levels. Each receiver has the option to abort the broadcast or pass it on to the next receiver.In ActionNow, let’s see how to send an ordered broadcast:public class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); // Create the intent for the ordered broadcast Intent orderedBroadcastIntent = new Intent(\"com.example.ORDERED_BROADCAST\"); orderedBroadcastIntent.putExtra(\"message\", \"Hello from MainActivity!\"); // Send the ordered broadcast sendOrderedBroadcast(orderedBroadcastIntent, null); }}And, how we can abort the broadcast, so that it is not delivered to any other receiver anymore:public class MyOrderedBroadcastReceiver extends BroadcastReceiver { @Override public void onReceive(Context context, Intent intent) { // Receive the broadcast String action = intent.getAction(); if (\"com.example.ORDERED_BROADCAST\".equals(action)) { // Log that the receiver has received the broadcast String message = intent.getStringExtra(\"message\"); System.out.println(\"Ordered Receiver Received: \" + message); // Do some processing or action here // Example of aborting the broadcast abortBroadcast(); // This will prevent further receivers from receiving the broadcast // Log that the broadcast has been aborted System.out.println(\"Ordered Receiver Aborted Broadcast\"); } }}In this MainActivity class, we create an intent for the ordered broadcast with the action \"com.example.ORDERED_BROADCAST\". We also put an extra message in the intent. Then, we send this ordered broadcast using sendOrderedBroadcast() method.With this setup, when MainActivity sends the ordered broadcast, MyOrderedBroadcastReceiver will receive it. In the MyOrderedBroadcastReceiver, it will log the message received and then abort the broadcast. As a result, no other receivers registered to receive this ordered broadcast will receive it.Make sure to register MyOrderedBroadcastReceiver in the manifest file. Also, ensure appropriate permissions are set if required.&lt;receiver android:name=\".MyOrderedBroadcastReceiver\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"com.example.ORDERED_BROADCAST\" /&gt; &lt;/intent-filter&gt;&lt;/receiver&gt;Modifying broadcast dataConsider example where initial broadcast sender sends a message as initialMessage in the following example, receiver overwrites that data so when the next receiver gets this broadcast delivered, it will get updated data.// Sending an Ordered Broadcast with initial dataString initialMessage = \"Hello from the sender!\";Intent intent = new Intent(\"com.example.ORDERED_BROADCAST\");intent.putExtra(\"message\", initialMessage);sendOrderedBroadcast(intent, null);Receiver manipulating data:public class OrderedBroadcastReceiver extends BroadcastReceiver { @Override public void onReceive(Context context, Intent intent) { String action = intent.getAction(); if (\"com.example.ORDERED_BROADCAST\".equals(action)) { // Retrieve the initial message from the broadcast String initialMessage = intent.getStringExtra(\"message\"); // Log.d initialMessage : Hello from the sender! // Modify the message String modifiedMessage = initialMessage.toUpperCase() + \"-Modified; // Example modification // Pass the modified message to the next receiver setResultData(modifiedMessage); } }}Now if the next receiver receives broadcast and prints the data it will get updated value:public class OrderedBroadcastReceiver extends BroadcastReceiver { @Override public void onReceive(Context context, Intent intent) { String action = intent.getAction(); if (\"com.example.ORDERED_BROADCAST\".equals(action)) { // Retrieve the initial message from the broadcast String modifiedMessage = intent.getStringExtra(\"message\"); // Log.d modifiedMessage : HELLO FROM THE SENDER!-Modified // This receiver can also abort further deliveries abortBroadcast(); } }}A Kotlin specific gist available here.When to Use Ordered BroadcastsOrdered broadcasts are useful when: A specific order of receiver execution is required. Receivers need to manipulate or filter the broadcast before passing it on. It’s necessary to ensure that only one receiver handles the broadcast.Comparison with normal broadcastWhile both types of broadcasts serve the purpose of inter-component communication, ordered broadcasts offer distinct advantages over normal broadcasts, especially when precise control and sequencing are paramount.Normal broadcasts (sendBroadcast()) are delivered to all registered receivers simultaneously and independently, without any predefined order or control over propagation. On the other hand, ordered broadcasts (sendOrderedBroadcast()) enable receivers to prioritize their execution and influence the delivery of the broadcast to subsequent receivers through methods like abortBroadcast().ConclusionOrdered broadcasts in Android empower developers with the ability to orchestrate the delivery of messages among components in a controlled and sequenced manner. By leveraging the structured delivery mechanism of ordered broadcasts, developers can ensure precise handling of events and streamline the execution flow within their applications.In scenarios where sequential execution or manipulation of broadcast propagation is required, ordered broadcasts emerge as a powerful tool in the Android developer’s arsenal.Further ReadingsBroadcasts OverviewBroadcast ReceiverOrdered BroadcastModifying Broadcast with setResult" }, { "title": "Android - Unit Testing for Dummies", "url": "/posts/unit-testing/", "categories": "Testing, Android", "tags": "android, unittesting, testing, mockito", "date": "2020-01-30 00:00:00 +0500", "snippet": "What is Unit Testing? In its simplest term, unit testing is testing a small piece of code. A unit test usually targets a single method that perform a single task. Test ensures that the code is b...", "content": "What is Unit Testing? In its simplest term, unit testing is testing a small piece of code. A unit test usually targets a single method that perform a single task. Test ensures that the code is behaving as expected and that code has a deterministic outcome.When the Unit Tests are written/run?There are generally 2 approaches when writing unit tests, One is test-driven-development, in which unit tests are written first, these tests specify requirements and at first they should fail because there is no code to produce required output, the code is then written around them to meet requirements and make tests pass. Other approach is retrospective testing, that is, after writing code, you write unit tests. This is more commonly used approach in practice (if there are unit tests written at all). You simply write code and then write unit tests after the code and validate code behaviours.With both approaches, it is a good practice to run unit tests as often as you can, after every code change, this will result in early identification of flaws in the system.Who writes Unit Tests? Developers. Period.Why should you write Unit Tests? Unit tests validate small pieces code for expected outcomes and report early issues. Unit tests also make sure that the code is giving errors where expected, this way a lot of corner cases are covered. Allows identification of logical bugs in the code when they are covering edge cases. If unit tests are written regularly, they make code resist to changes that breaks the code. If a change in the code fails the unit test, either the code has issue or test is not updated, both ways, its a warning sign for developer to put an extra effort to investigate the issue before closing the development cycle. It seems waste of time and extra effort at the beginning, and it is, but few days effort of maintaining the code with meaningful unit tests saves months of refactoring later. It makes code cleaner – since the tests require certain level of abstraction and loose coupling which make code more cleaner.Intention The purpose of this writing is to promote the unit tests in software projects, specially those which are shaping the way we live, these projects can be related to finance, medicine, transport or online shopping. The bugs or problems in these software causes both customers and developers to lose their time and money. Promoting unit tests can save a lot of time in covering basic business logic validations and resulting a reliable software which can be fruitful for all the entities in the business. Writing unit test for the sake of unit tests or say achieving high code coverage is not a good idea. If the tests are not playing their part in verifying business flows, they are of no value. In programming, every line of code generates a business value, no one likes to lose business, unit tests verify that the business value that code aims to provide is on the spot.Writing Testable Code – A prerequisite (IMPORTANT) Unit tests are written in controlled environment, this helps you provide certain conditions under which you expect certain outcomes. If you cannot control the agents or entities that are driving these conditions you cannot be sure about the outputs. This test environment is largely controlled using dependencies you provide to the test case. First and foremost thing is separating the dependencies from the code. For this you should be able to recognize what are the dependencies and what is the actual code that needs to be tested. In terms of Java and Android, if you are working in Android, your business layer should be testable without any Android dependencies. Continuing on Android as example, for the business layer (and unit tests themselves), most of the Android framework stuff will be dependencies for code. Like network library, Retrofit. Considering framework elements as dependencies is helpful but you still need a layer of abstraction so you can drive these framework objects the way you want to, consider following:Instead of:public UserService(User user, Retrofit retrofit)Use some abstraction:public UserService(User user, Request userRequest) Using an abstraction layer of Request class to wrap retrofit in it so the code doesn’t depend on Android Retrofit. Creation of objects should be delegated to upper level, like dependency manager. If a class that needs to be tested is creating its own objects inside, you cannot control data in those objects to test.Instead of using “new” keywords (constructors/initializers) in code:public UserService(User user){ request = new Request(); ... }Use dependency injection:public UserService(User user, Request userRequest) You have now control over creation. You can also use dependency managers like Dagger2 and “inject” this dependency here. Another important thing to mention here is composition over inheritance will always be in favour of testable code. Since composition gives you more control over objects when you are using dependency injection, you can easily control these objects in test environment. In above example UserService, you can provide a UserValidator instead of implementing it. Just like UserRepo and Request, it can follow composition. But the abstraction is still maintained since no concrete references are used here.Instead of:public class UserService implements UserValidator{...}You can do:// constructor injectionpublic UserService(User user, Request userRequest, UserValidator validator) Separate creation logic from business logic, that’s what dependency managers do, if this is not the case, you might miss some business logic to test which was ran during creation of objects. Since tests and business classes should not be responsible for creating objects involved in a business logic flow.Avoid writing business logic in constructor or anywhere in creation classes like dependency managers: public UserService(User user, Request userRequest){ if(userRequest !=null){ this.userRequest= userRequest; // This block is never tested since it is just creation block } } Unit tests usually targets business layer, so regardless of any framework you are, your code that needs to be tested must be using the core language libraries. A good way to realize this in Java/Kotlin is to look at imports section. If there is an import that is not coming from core Java/Kotlin it should raise alarm. import android.os.Bundle; // --- This is not good in business layerimport android.view.View; // --- This is not good in business layerimport com.selfsol.app.models.user; // --- This is okay as it is a POJO model First priority should be to avoid such dependencies, if not possible their creation should be delegated to dependency managers with proper abstractions. So when this class is tested, these dependencies can easily be mocked with dummy values or behavior and unit tests are not blocked. Its nice to have to follow an architectural pattern to manage code, whether it be MVVP, MVP, VIPER or any other, primary goal is to make code clean, maintainable and testable, which makes it helpful to work with such codebase in the longer run. The implementation of architecture doesn’t really provide all the solutions, so there are still few things that needs to be decoupled, like networking and UI stuff.Following example illustrates how this abstraction can be achieved and how it is created in dependency manager layer:// class for abstraction of network librarypublic interface Request { void execute( T data);}// class having real network classes and implementationpublic class UserRequest implements Request{ ...}// creation of this classpublic class SomeDependencyProvider(){ // notice interface reference in return type public Request createRequestObject(){ return new UserRequest(); }}Generally, you don’t need network or UI when writing unit tests, so if there is a good abstraction layer between the business logic layers and UI or Network etc, it will help you mock these entities and validate the actual business logic in tests. Static methods makes it hard to test unless they are pure methods and do not use or create any dependency objects in their execution, moreover these static methods or objects cannot be mocked easily which are blocker in unit testing.Consider following class in which one method is acceptable but the other one creates trouble:public class Utils{ // this wont be any trouble public static boolean isEmptyString( String string){ return string !=null &amp;&amp; !string.isEmpty(); } // this will cause issue since this is using an object that is in its static scope and cannot be mocked public static Date formatDate(String pattern, long timeInMillis){ DateFormatter formatter = new DateFormatter( pattern ); return formatter.format( timeInMillis ); } }In other words, static classes cant be used with dependency injections so they lack this flexibility of being separating creation logic from actual business logic. This brings you to the point number 1, where you are unable to control the test environment. Tests are written for public methods. Because other classes or layers call public methods of classes that provide business logic. These methods in turn, call private methods which itself covers these private methods. DON’T make private methods public for just writing TESTS. public class UserService{ public boolean validateUser(User user){ validateAge(age); } private boolean validateAge(int age){ }} In above example, you will write test for validateUser(), which will also cover validateAge(), if you do want to test such methods individually you can introduce an interface that contains these signatures, in this way these methods will hide their implementation details and yet they will be accessible for testing from outside or mocking if required. When writing a test for a class, the target class should be instantiated as a concrete implementation, so the real code is ran, and all other participating objects are mocked. If the participating objects have abstraction (they are interface objects), mocking becomes easy.Consider writing test for UserService:@RunWith(MockitoJUnitRunner.class)public class UserServiceTest { // Class reference private UserService userService; // interface reference mocked @Mock Request request; // interface reference mocked @Mock UserRepo userRepo;...}You can later define how “request” behaves when its methods are called, same for “userRepo”. Point is, making them abstract, decoupled and using dependency injection pattern, it is easier to control these participating objects and you can design your test by providing values and behaviours the way you like to.Writing Unit TestsIn the following discussion I will be using Java as the example language and some references from Android Framework. Regardless of this fact, the general guidelines and practices will apply to any OOP based framework. You will use Java and its testing framework JUnit in these examples, moreover, you will refer Mockito for mocking objects. You will focus on UserService (or UserManager) example, in which, you will validate creation of valid users in a system. You will not test classes that serves as dependencies in the UserService, these are UI classes referred as “View” in most of the architectures and Network classes like Request or Response. You will mock these dependencies. It is not your responsibility to test 3rd Party library classes like Retrofit, Gson, Picasso, OkHttp etc. Meaningful names of test methods should be used, these names can be longer as long as they are self explanatory. AAA Testing Pattern – Arrange, Act, Assert is the pattern you will use and it goes as follows: Arrange: Setup objects, parameters and environment for the test Act: Perform action, the actual code is ran on which test is to be done Assert: Assertion or validation is made on the action that was performed if it is giving required results or not See UserServiceTest for details.ArrangeSet dummy inputs for data before executing actual test call. If there are any methods to be mocked, they are also done in this phase.Lets declare objects first: private UserService userService; @Mock Request request; @Mock UserRepo userRepo;How mocks work? // MockitoJunitRunner initializes mocks itself when tests starts @RunWith(MockitoJUnitRunner.class) public class UserServiceTest { ...Setting up the Test Class:userService = new UserService(request, userRepo); // in @Before methodThe setup seems easy and simple because you already followed the practices in the code that are test friendly, here using injection pattern instead of creating dependencies in the object itself. You were able to provide UserRepo and Request from outside based on your requirement here.Setting up requirement that are specific to the test case: @Test public void testValidAge_inputPositiveNumber_shouldValidateSuccess() { // Arrange val testAge = 18 ... }ActNow you perform your test: @Test public void testValidAge_inputPositiveNumber_shouldValidateSuccess() { ... // Act boolean result = userService.validateAge(testAge); ... }This is how you right test in JUnit. Notice that the function name is like a sentence that tells the whole story. In source code, this convention may not be liked in general, but in tests, this is preferred. It explains a lot about the test. Since tests dont have that amount of documentation that code has (if any), this is important. The convention goes like this:testMethod_conditions_outcomes()Then the “act” happens. The method is called and the value is captured.Assert @Test public void testValidAge_inputPositiveNumber_shouldValidateSuccess() { // Arrange ... // Act ... // Assert assertTrue(\"Expected to validate positive number as valid age but failed\", result); } The value captured in the act is asserted to be true or false. The assertTrue is a JUnit assertion method which checks the given condition along with option to provide a message in case of failure. Let’s not go into implementation at this point just the approach. All the implementations are left blank.There is a message Expected to validate positive number as valid age but failed passed as 1st parameter. This is failure message. It is important to flag failures with meaningful messages. So when someone come across a failed test case in the log, s/he can identify what is the problem. This is also a good practice.But wait, your code is not that simple!In most of the cases, this assert flow works in tests. But sometimes the methods don’t return values. Like in VIPER which uses callback pattern. In this case view is holding reference to presenter and a view reference is inside a presenter. View calls presenter.fetchSomething() this method does not return anything but after it fetches, it calls view.onSuccessfulFetch(). How can you test presenter since its methods don’t return anything?Similarly in case of Request when the UserService calls createUser(User user), it doesn’t do anything. It calls request.execute(user, this) and return nothing.There are two things you can do to test the flows or method that dont return anything: If the method calls another method on any other object, this method call can be verified using Mockito framework. This is called testing interactions where you cannot test states (asserting values). Check if the code runs without any exception. This is not the only thing you should be doing, but in rare cases like these, this is important factor.Following code piece can illustrate this as: @Test public void testCreateUser_validUserProvided_shouldCallRequestExecuteWithUser(){ // act userService.createUser(user); // assert Mockito.verify(request).execute(user, userService); }One of the coolest thing that this verify does is that it matches the parameter with actual call. For example:Mockito.verify(request).execute(user, userService);will pass the test, butMockito.verify(request).execute(null, userService);will fail, why? Because the actual call used same object as you mentioned. This was your specific case where you knew both parameters, but cases where you don’t know the exact parameters, you can specify any() in parameter to allow any object with any value. You can also narrow down this to specific type calling any(String.class) this will allow objects with only string type but with any value in it.Mockito.verify(request).execute(any(), userService);This is really useful in callback patterns. In simple method call a value is returned. In callbacks, the value is returned in a callback’s success method as parameters. Consider following asynchronous call made for validation earlier:// simple callboolean result = userService.validateAge(18);And its callback version would look like:userService.validateAge(18, validationCallback);....and where the validation callback is implemented:...onValidationComplete(boolean success){...}You can see that boolean value that was returned in simple call is now a parameter for callback’s method. Considering same example you can write assertion as:Mockito.verify(validationCallback).onValidationComplete(true);This should work right? No. Since the object is mocked you have to specify that when this asynchronous call is made, you need to invoke onValidationComplete(). If this object was not a mock object, the above assertion along with following mocking would not be possible. Why asynchronous is mentioned before? because going on callback pattern has one main purpose of being non-blocking operations.So how are you going to mock the behavior of these objects? Mocking a method of an object that is marked as Mock is as easy as:// this should be done in \"Arrange\" phase, in your case in setup() methodMockito.when(userValidator.validateId(l363)).thenReturn(true);This will setup userValidator to return true when its validateId() is called with id 1363. Similarly you can design many flows using same approach including multiple happy cases and also failure cases to test if code gives expected output on wrong inputs. All great but this is not applicable for callback/asynchronous methods.Luckily, in Java, you have Mockito‘s Answer to solve the problem. But you have to make another change. Since you want to mock response, you will have to provide it as dependency. See this is how unit tests can help refactor your code to be more decoupled and resilient. Now coming back to point.Making Response testable in UserService: (Refer to UserService2)public class UserService2 implements UserValidator { // notice it is not implementing Response Callback now private Request request; private UserRepo repo; private Response responseCallback; public UserService2(Request request, UserRepo repo, Response response) { this.request = request; this.repo = repo; responseCallback= response; } ...}Mocking Callback object so its calls can be tested using Mockito: (See UserService2Test)@RunWith(MockitoJUnitRunner.class)public class UserService2Test { private UserService2 userService; @Mock Request request; @Mock UserRepo userRepo; @Mock User user; @Mock private Response response; @Before public void setup() { userService = new UserService2(request, userRepo, response); } @Test public void testCreateUser_validUserProvided_shouldCallRequestExecuteWithUser() { // arrange mockRequestCallbackResponse(); // act userService.createUser(user); // assert Mockito.verify(request).execute(user, response); // verify request.execute was called Mockito.verify(response).onSuccess(user); // verify callback method was called with parameter specified } // call onSuccess on 2nd argument object as in invocation.getArguments()[1] (0 - first, 1 - second) private void mockRequestCallbackResponse() { Mockito.doAnswer((Answer) invocation -&gt; { Response callback = (Response) invocation.getArguments()[1]; callback.onSuccess(user); return null; // when request.execute is called }).when(request).execute(user, response); }}This is like: When request.execute(user, response) is called, call onSuccess(user) on response object that was passed. And the parameter checks will work like same as mentioned before.Mockito in KotlinKotlin reflections work little bit different than java, in above examples, You have used java, but it should be same for Kotlin, except one thing, mockito you used above cannot mock Kotlin classes. There is a very useful library available on github as nhaarman/mockito-kotlin (Now officially available in Mockito as of January 2024). This has pretty much everything you need in Kotlin, so you are good to go!Architecture Components – Can You write unit tests?Now, you have seen drastic improvements in terms of architecture favoured official libraries from Android Team at Google, most prominently, you see MVVM is pushed as standard way of writing Android apps. It’s very easy to loose the sense of writing SOLID code if you don’t have a good understanding of layered architectures, when you have such libraries as LiveData, Room, ViewModel and the awesome Flow API. The point is, no matter how good or efficient these libraries are, your code must have testing module. This argument is supported with the fact that team at Google has always mentioned libraries supporting tests and showing test samples in conferences and talks throughout releases of AndroidX Libraries. There are a lot of resources to get you started testing your MVVM app. One of my personal favorite is Codelab.The point is, no matter what architecture or libraries are used, if code is well written there will always be a way to write meaningful unit tests. So don’t get lost in fantasies of modern APIs, in fact do get lost in them, explore, try and break them, but remember the fundamental goal : clean; working; bug free code.Cook your own recipeThere is a fair chance that none of above mentioned architectures or libraries are being used in your project. If you remember at the start, its mentioned that most of the guidelines are independent and would like to point that out here again. Cook your own recipe, take ingredients from clean code and official stable libraries. Make sure whatever architecture or libraries you are using is, in its simplest form, loosely coupled and testable.Key TakeawaysNow you have powerful tools at your disposal to write unit tests for most of the code in your project. To put things in perspective, testing on methods that return anything is done with simple asserts that test state of returned values. Testing on methods that don’t return anything is done with verify. Although it takes much effort to test methods that return no value, but you can actually test the whole interaction along with testing state of the parameters which are same as returned values most of the time.Some developers take approach of mocking servers that use Retrofit callbacks and those clients. The goal in unit tests is just to mock this layer and if you can do it in a simpler way with just using Mockito in Java why not go for it, although this way needs an abstraction layer but that’s what makes code loosely coupled. This is also applicable to testing network calls, I/O asynchronous calls or any long running operation that business logic involves. As long as dependencies are well managed and code is loosely coupled, you can almost write test in any case!Feel free to give feedback on what I might have missed or what can be improved in this small piece of writing. Find the source code of example classes here. Thanks for reading!And remember to follow https://testing.googleblog.com/ for updates on new testing libraries and approaches. And https://android-developers.googleblog.com/ for the latest Android news and blogs." }, { "title": "Unconventional Raycasting", "url": "/posts/ray-casting/", "categories": "Unity3d", "tags": "raycasting, unity3d", "date": "2015-09-15 00:00:00 +0500", "snippet": "Unconventional RaycastingIf you have not worked on any FPS or any other shooter game until now, it is easy to predict that you would not have needed the raycasting other than conventional way. The ...", "content": "Unconventional RaycastingIf you have not worked on any FPS or any other shooter game until now, it is easy to predict that you would not have needed the raycasting other than conventional way. The commonly used raycasting techniques include the directions up or down, right or left, or forward or backwards.It can be quite difficult when the angle at which ray to be casted is, say, 45 degrees up, like for flak cannons or SAMs. In this case we can not use simple transform.up with say some +45 or -45 angles. This is possible by specifying the axis. What if the angle we need is something 56 degrees on x-axis and 120 degrees y-axis? And what if you have to design something when there is change in direction after every frame or a callback implementation. This following tryout demonstrates how easily you can manage to set the angle of the ray where to be casted just by few simple tweaks in your traditional raycasting code.The whole project which is in this tutorial can be downloaded from GitHub from here.Now first, we need an origin from which ray will be generated, at this moment we are assuming that our origin stays at a fixed position, but we can alter it the way we want. In my case, I have created a scene where a plane is aiming using raycast to determine the aim direction. The origin is the nose tip of the plane from where ray is generated. The plane is in a large box to make the raycasting work. One thing to remember here is that Physics.Raycast returns true only when raycast hits a collider, so we can not do this in open sky. Due to the enclosing box, no matter in which direction the ray is casted, it will be detected. The scene looks like this:It is not very fancy but it will do the trick. Now we need to have a look at our script. Open file named ‘BasicControl.cs’ in the assets folder of the project and you will see following code:public class BasicControl : MonoBehaviour { public float x = 10, y = 0, z = 0; // angles public GameObject AirCraft;public GameObject rayCastOrigin; RaycastHit RayHit; void Update () { if (Physics.Raycast(rayCastOrigin.transform.position, Quaternion.Euler(x, y, z) * transform.forward, out RayHit, Mathf.Infinity)) { Debug.DrawLine(rayCastOrigin.transform.position, RayHit.point, Color.red); } }}By setting the access modifier of float x,y,z to public we can change there values from the editor even at runtime. Here x, y and z represents the angles at x , y and z axes respectively. The RaycastHit object tells us the details about the game object on which ray is hit, that is why we have to make sure ray hits something,if (Physics.Raycast(rayCastOrigin.transform.position, Quaternion.Euler(x, y, z) * transform.forward, out RayHit, Mathf.Infinity))Then, if ray collides with an object, RaycastHit collects data of that object which can be used in various ways. Here we are using the position of the object which is being hit by RayHit.point property , it returns x,y,z co ordinates of that object. Rays are not rendered either in scene or game window, so we draw a line from our origin point rayCastOrigin.transform.position to that object.Debug.DrawLine(rayCastOrigin.transform.position, RayHit.point, Color.red);By doing this we will see a line drawn in the path of the ray, which will be visible in scene window. Run the project, click on the Aircraft , you will see the Script component where it shows Basic Control script and its public variables X , Y and Z.Change the values of these and see how it affects the angle of ray. Now we can adjust the direction of the ray at any angle required. The script can be edited to change the angle at every frame to give it a radar effect. Or set the ray angle in desired direction and save x, y, z angles for other uses.Download project.Photo Credit: Laura Harris (Flickr)" } ]
